<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comfy Team PR Speed Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: auto;
        }

        /* Floating TOC styles */
        .toc {
            position: fixed;
            left: 20px;
            top: 80px;
            width: 180px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 15px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            z-index: 100;
        }

        .toc h3 {
            font-size: 0.9em;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #007bff;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toc h3::after {
            content: '‚ñº';
            font-size: 0.7em;
            transition: transform 0.3s ease;
        }

        .toc.collapsed h3::after {
            transform: rotate(-90deg);
        }

        .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .toc.collapsed ul {
            display: none;
        }

        .toc.collapsed {
            width: auto;
            min-width: 50px;
        }

        .toc.collapsed h3 {
            border-bottom: none;
            margin-bottom: 0;
            font-size: 0.8em;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .toc li {
            margin-bottom: 8px;
        }

        .toc a {
            color: #666;
            text-decoration: none;
            font-size: 0.85em;
            display: block;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .toc a:hover {
            background: #f0f7ff;
            color: #007bff;
            transform: translateX(5px);
        }

        .toc a.active {
            background: #007bff;
            color: white;
            font-weight: 500;
        }

        /* Responsive - hide TOC on small screens */
        @media (max-width: 1200px) {
            .toc {
                display: none;
            }
            .container {
                margin-left: auto;
            }
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .card h2 {
            font-size: 1.2em;
            color: #444;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .metric-label {
            color: #666;
            font-size: 0.9em;
        }

        .metric-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #333;
        }

        .metric-value.success {
            color: #28a745;
        }

        .metric-value.warning {
            color: #ffc107;
        }

        .metric-value.danger {
            color: #dc3545;
        }

        .chart-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .chart-container h2 {
            font-size: 1.4em;
            color: #444;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        .chart-container h2 a {
            color: #444;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .chart-container h2 a:hover {
            color: #007bff;
            text-decoration: underline;
        }

        html {
            scroll-behavior: smooth;
        }

        /* Date range slider styles */
        .range-slider {
            position: relative;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
        }

        .range-slider-track {
            position: absolute;
            height: 100%;
            background: #007bff;
            border-radius: 4px;
            cursor: grab;
            transition: background 0.2s ease;
        }

        .range-slider-track:hover {
            background: #0056b3;
        }

        .range-slider-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #007bff;
            border: 2px solid white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 2;
        }

        .range-slider-handle:hover {
            background: #0056b3;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .range-slider-handle.dragging {
            background: #0056b3;
            transform: translate(-50%, -50%) scale(1.15);
        }

        #quarterly-btn:hover {
            background: #007bff !important;
            color: white !important;
            border-color: #007bff !important;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .axis {
            font-size: 12px;
        }

        .axis-label {
            font-size: 14px;
            font-weight: 600;
        }

        .bar {
            transition: opacity 0.3s;
        }

        .bar:hover {
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #666;
        }

        #last-updated {
            text-align: center;
            color: #999;
            font-size: 0.9em;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        /* Enhanced select and input styles for Gantt controls */
        #gantt-chart-section select:hover,
        #gantt-chart-section input[type="text"]:hover {
            border-color: #007bff;
            transition: border-color 0.2s ease;
        }

        #gantt-chart-section select:focus,
        #gantt-chart-section input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        @media (max-width: 768px) {
            #gantt-chart-section .controls > div:first-child {
                grid-template-columns: 1fr !important;
            }
        }

        @media (max-width: 1024px) {
            #gantt-chart-section .controls > div {
                grid-template-columns: 1fr !important;
            }
        }

        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #0056b3;
        }

        button.active {
            background: #28a745;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }

        .stats-table th,
        .stats-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .stats-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .stats-table tr:hover {
            background-color: #f5f5f5;
        }

        .stats-table .number {
            text-align: right;
        }

        .expandable-row {
            cursor: pointer;
        }

        .expandable-row:hover {
            background-color: #e9ecef !important;
        }

        .detail-row {
            background-color: #f8f9fa;
            display: none;
        }

        .detail-row.expanded {
            display: table-row;
        }

        .detail-content {
            padding: 20px;
            border-left: 4px solid #007bff;
        }

        .repo-breakdown, .quarter-breakdown {
            display: inline-block;
            margin-right: 30px;
            vertical-align: top;
        }

        .breakdown-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #495057;
        }

        .breakdown-item {
            margin-bottom: 5px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <!-- Floating Table of Contents -->
    <nav class="toc" id="toc">
        <h3>üìë Quick Navigation</h3>
        <ul>
            <li><a href="#overview-section">üìä Overview</a></li>
            <li><a href="#member-distribution-section">üë• PR Distribution</a></li>
            <li><a href="#repo-time-section">üè¢ Repository Stats</a></li>
            <li><a href="#quarterly-trends-section">üìà Quarterly Trends</a></li>
            <li><a href="#status-distribution-section">üéØ Status Distribution</a></li>
            <li><a href="#time-distribution-section">üìâ Time Distribution</a></li>
            <li><a href="#boxplot-section">üìä Box Plot</a></li>
            <li><a href="#member-stats-section">üìã Member Statistics</a></li>
            <li><a href="#gantt-chart-section">üìÖ Gantt Chart</a></li>
            <li><a href="#dig-for-more">üîç Dig for More</a></li>
        </ul>
    </nav>

    <div class="container">
        <h1>Comfy Team PR Speed Analysis</h1>
        <p class="subtitle">Pull Request Metrics Dashboard</p>


        <div id="last-updated"></div>


        <div class="dashboard" id="overview-section" style="grid-template-columns: 1fr 1fr 300px;">
            <div class="card">
                <h2>PR Overview</h2>
                <div class="metric">
                    <span class="metric-label">Total PRs</span>
                    <span class="metric-value" id="total-prs">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Merge Rate</span>
                    <span class="metric-value success" id="merge-rate">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Avg Time to Merge</span>
                    <span class="metric-value" id="avg-merge-time">-</span>
                </div>
                <hr style="margin: 15px 0; border: none; border-top: 1px solid #e0e0e0;">
                <div class="metric">
                    <span class="metric-label">Merged</span>
                    <span class="metric-value success" id="merged-count">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Open</span>
                    <span class="metric-value warning" id="open-count">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Closed</span>
                    <span class="metric-value danger" id="closed-count">-</span>
                </div>
                <hr style="margin: 15px 0; border: none; border-top: 1px solid #e0e0e0;">
                <div class="metric">
                    <span class="metric-label">Contributors</span>
                    <span class="metric-value" id="active-contributors">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Repositories</span>
                    <span class="metric-value" id="repo-count">-</span>
                </div>
            </div>

            <div class="card">
                <h2>Performance</h2>
                <div class="metric">
                    <span class="metric-label">Fastest Merge</span>
                    <span class="metric-value" id="fastest-merge">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">25th Percentile</span>
                    <span class="metric-value" id="p25-merge">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Median Merge</span>
                    <span class="metric-value" id="median-merge-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">75th Percentile</span>
                    <span class="metric-value" id="p75-merge">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">90th Percentile</span>
                    <span class="metric-value" id="p90-merge">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">95th Percentile</span>
                    <span class="metric-value" id="p95-merge">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Slowest Merge</span>
                    <span class="metric-value" id="slowest-merge">-</span>
                </div>
            </div>

            <div class="card">
                <h2>Filters</h2>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; color: #666; font-size: 0.9em;">Filter by User</label>
                    <select id="dashboard-filter-user" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">All Users</option>
                    </select>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; color: #666; font-size: 0.9em;">Filter by Repository</label>
                    <select id="dashboard-filter-repo" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">All Repositories</option>
                    </select>
                </div>
                <div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <label style="color: #666; font-size: 0.9em; flex-grow: 1;">Filter by Date Range</label>
                        <button id="quarterly-btn" style="padding: 4px 10px; font-size: 12px; background: #f0f0f0; border: 1px solid #ddd; border-radius: 3px; cursor: pointer; color: #666;">Quarterly</button>
                    </div>
                    <div id="date-range-container" style="position: relative; padding: 15px 0;">
                        <div id="date-range-slider"></div>
                        <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 12px; color: #666;">
                            <span id="date-range-start">-</span>
                            <span id="date-range-end">-</span>
                        </div>
                    </div>
                </div>
                <button id="reset-filters" style="width: 100%; margin-top: 20px; padding: 10px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Reset Filters</button>
            </div>
        </div>

        <div class="chart-container" style="background: #f8f9fa; border-left: 4px solid #007bff;">
            <h2 style="color: #007bff;">Understanding This Dashboard</h2>

            <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border-radius: 5px; border-left: 4px solid #f39c12;">
                <strong>‚ö†Ô∏è Important Note:</strong> This report only analyzes contributions made through <strong>Pull Requests (PRs)</strong> from the following repositories:
                <strong id="repo-list">Loading...</strong>.
                Direct commits to repositories are <strong>not included</strong> in this analysis. Some contributors like
                <strong>comfyanonymous</strong> may have extensive direct commit activity that is not reflected in these metrics.
            </div>

            <h3 style="margin-top: 20px; color: #333;">üìä Understanding Percentile Metrics</h3>
            <p style="line-height: 1.8; color: #555;">
                Percentiles help us understand the distribution of PR merge times and identify bottlenecks in our development velocity:
            </p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 20px 0;">
                <div style="padding: 15px; background: white; border-radius: 5px; border-left: 3px solid #28a745;">
                    <strong style="color: #28a745;">P50 (Median)</strong>
                    <p style="font-size: 14px; color: #666; margin: 5px 0;">
                        50% of PRs merge faster than this time. This represents the "typical" PR experience and is less affected by outliers than the average.
                    </p>
                </div>

                <div style="padding: 15px; background: white; border-radius: 5px; border-left: 3px solid #ffc107;">
                    <strong style="color: #856404;">P75</strong>
                    <p style="font-size: 14px; color: #666; margin: 5px 0;">
                        75% of PRs merge faster than this time. PRs taking longer than P75 may indicate complex changes or review bottlenecks.
                    </p>
                </div>

                <div style="padding: 15px; background: white; border-radius: 5px; border-left: 3px solid #dc3545;">
                    <strong style="color: #dc3545;">P95</strong>
                    <p style="font-size: 14px; color: #666; margin: 5px 0;">
                        95% of PRs merge faster than this time. PRs exceeding P95 are outliers that significantly impact development velocity.
                    </p>
                </div>
            </div>
        </div>

        <div class="chart-container" id="member-distribution-section">
            <h2><a href="#member-distribution-section">PR Distribution by Member</a></h2>
            <div id="member-chart"></div>
        </div>

        <div class="chart-container" id="repo-time-section">
            <h2><a href="#repo-time-section">Average Merge Time by Repository</a></h2>
            <div id="repo-time-chart"></div>
        </div>

        <div class="chart-container" id="quarterly-trends-section">
            <h2><a href="#quarterly-trends-section">Quarterly PR Trends</a></h2>
            <div id="quarterly-chart"></div>
        </div>

        <div class="chart-container" id="status-distribution-section">
            <h2><a href="#status-distribution-section">PR Status Distribution</a></h2>
            <div id="status-pie-chart"></div>
            <h3>By Member</h3>
            <div id="member-status-charts" style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;"></div>
        </div>

        <div class="chart-container" id="time-distribution-section">
            <h2><a href="#time-distribution-section">Merge Time Distribution</a></h2>
            <div id="distribution-histogram"></div>
        </div>

        <div class="chart-container" id="boxplot-section">
            <h2><a href="#boxplot-section">Box Plot - Merge Time by Member</a></h2>
            <div id="member-boxplot"></div>
        </div>

        <div class="chart-container" id="member-stats-section">
            <h2><a href="#member-stats-section">Detailed Member Statistics</a></h2>
            <div id="member-details-table"></div>
        </div>

        <div class="chart-container" id="gantt-chart-section">
            <h2><a href="#gantt-chart-section">Individual PR Gantt Chart</a></h2>
            <div class="controls" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
                        <div id="gantt-stats" style="padding: 15px; background-color: white; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; line-height: 1.6; word-wrap: break-word;">
                            <div style="color: #666; margin-bottom: 5px; font-weight: 600;">Current Filters</div>
                            <div style="color: #333;">Loading...</div>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #666; font-size: 0.85em; font-weight: 500;">Sort by</label>
                            <select id="gantt-sort" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; font-size: 14px;">
                                <option value="created">Created Date</option>
                                <option value="closed">Closed/Merged Date</option>
                                <option value="user">User</option>
                                <option value="repository">Repository</option>
                                <option value="duration">Duration</option>
                                <option value="status">Status</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #666; font-size: 0.85em; font-weight: 500;">Filter by User</label>
                            <select id="gantt-filter-user" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; font-size: 14px;">
                                <option value="">All Users</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #666; font-size: 0.85em; font-weight: 500;">Filter by Repository</label>
                            <select id="gantt-filter-repo" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; font-size: 14px;">
                                <option value="">All Repositories</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; color: #666; font-size: 0.85em; font-weight: 500;">Filter by Status</label>
                            <select id="gantt-filter-status" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; font-size: 14px;">
                                <option value="">All Statuses</option>
                                <option value="merged">Merged</option>
                                <option value="open">Open</option>
                                <option value="closed">Closed</option>
                            </select>
                        </div>
                    </div>
                    <div style="padding: 20px; background: white; border-radius: 6px;">
                        <label style="display: block; margin-bottom: 15px; color: #666; font-size: 0.85em; font-weight: 500;">Filter by Date Range</label>
                        <div id="gantt-date-range-slider" style="margin-bottom: 15px;"></div>
                        <div style="display: flex; justify-content: space-between; font-size: 13px; color: #555; margin-bottom: 20px;">
                            <span id="gantt-date-start" style="font-weight: 500;">-</span>
                            <span style="color: #999;">to</span>
                            <span id="gantt-date-end" style="font-weight: 500;">-</span>
                        </div>
                        <label style="display: block; margin-bottom: 10px; color: #666; font-size: 0.85em; font-weight: 500;">Search by Keywords</label>
                        <input type="text" id="gantt-search-keywords"
                               placeholder="Enter keywords separated by spaces (e.g., fix bug ui)"
                               style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <div style="margin-top: 5px; font-size: 11px; color: #999;">
                            Searches in PR titles. All keywords must match.
                        </div>
                    </div>
                </div>
            </div>
            <div id="gantt-chart"></div>
        </div>
    </div>

    <script>
        let globalData = null;
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        function loadData() {
            // Show loading state
            document.getElementById('total-prs').textContent = 'Loading...';

            // Load data from JSON file
            fetch('data.json')
                .then(response => response.json())
                .then(data => {
                    globalData = data;

                    // Populate filter dropdowns
                    populateFilters(data);

                    // Initial dashboard update with no filters
                    updateDashboard(data);
                    renderCharts(data);
                    document.getElementById('last-updated').textContent =
                        `Last updated: ${new Date(data.generatedAt).toLocaleString()}`;
                })
        }

        let dateRangeValues = { start: null, end: null };

        function createDateRangeSlider(data) {
            // Get date range from data
            const dates = data.allPRs.map(pr => new Date(pr.created_at).getTime());
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            const today = new Date();
            today.setHours(23, 59, 59, 999); // End of today

            // Initialize with full range (up to today)
            dateRangeValues.start = minDate;
            dateRangeValues.end = today;

            const container = document.getElementById('date-range-slider');
            container.innerHTML = '';

            // Create slider elements
            const slider = document.createElement('div');
            slider.className = 'range-slider';

            const track = document.createElement('div');
            track.className = 'range-slider-track';

            const handleStart = document.createElement('div');
            handleStart.className = 'range-slider-handle';
            handleStart.id = 'handle-start';

            const handleEnd = document.createElement('div');
            handleEnd.className = 'range-slider-handle';
            handleEnd.id = 'handle-end';

            slider.appendChild(track);
            slider.appendChild(handleStart);
            slider.appendChild(handleEnd);
            container.appendChild(slider);

            // Update positions
            updateSliderPositions();

            // Add drag functionality
            let dragging = null;
            let dragStartX = 0;
            let originalStartDate = null;
            let originalEndDate = null;
            let updateTimeout = null;

            // Throttle function for updates
            function throttledApplyFilters() {
                if (updateTimeout) return; // Skip if already scheduled

                updateTimeout = setTimeout(() => {
                    applyFilters();
                    updateTimeout = null;
                }, 100);
            }

            function startDrag(e, element) {
                e.preventDefault();
                e.stopPropagation();
                dragging = element;
                dragStartX = e.clientX;
                originalStartDate = new Date(dateRangeValues.start.getTime());
                originalEndDate = new Date(dateRangeValues.end.getTime());

                if (element.classList.contains('range-slider-handle')) {
                    element.classList.add('dragging');
                } else if (element.classList.contains('range-slider-track')) {
                    track.style.cursor = 'grabbing';
                }
            }

            function drag(e) {
                if (!dragging) return;

                const rect = slider.getBoundingClientRect();

                if (dragging.classList.contains('range-slider-track')) {
                    // Dragging the track - move both handles together
                    const deltaX = e.clientX - dragStartX;
                    const deltaPercent = deltaX / rect.width;
                    const deltaTime = deltaPercent * (maxDate.getTime() - minDate.getTime());

                    let newStartTime = originalStartDate.getTime() + deltaTime;
                    let newEndTime = originalEndDate.getTime() + deltaTime;

                    // Constrain to bounds
                    if (newStartTime < minDate.getTime()) {
                        const shift = minDate.getTime() - newStartTime;
                        newStartTime = minDate.getTime();
                        newEndTime += shift;
                    }

                    if (newEndTime > today.getTime()) {
                        const shift = newEndTime - today.getTime();
                        newEndTime = today.getTime();
                        newStartTime -= shift;
                        // Don't let start go below min
                        if (newStartTime < minDate.getTime()) {
                            newStartTime = minDate.getTime();
                        }
                    }

                    dateRangeValues.start = new Date(newStartTime);
                    dateRangeValues.end = new Date(newEndTime);
                } else {
                    // Dragging a handle
                    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));

                    // Map percentage to date, but treat 100% as today
                    let dateValue;
                    if (percent >= 0.99) { // Near the end means today
                        dateValue = today;
                    } else {
                        dateValue = new Date(minDate.getTime() + percent * (maxDate.getTime() - minDate.getTime()));
                    }

                    if (dragging.id === 'handle-start') {
                        dateRangeValues.start = new Date(Math.min(dateValue.getTime(), dateRangeValues.end.getTime()));
                    } else {
                        dateRangeValues.end = new Date(Math.max(dateValue.getTime(), dateRangeValues.start.getTime()));
                    }
                }

                updateSliderPositions();
                throttledApplyFilters(); // Apply filters with throttling while dragging
            }

            function stopDrag() {
                if (dragging) {
                    if (dragging.classList.contains('range-slider-handle')) {
                        dragging.classList.remove('dragging');
                    } else if (dragging.classList.contains('range-slider-track')) {
                        track.style.cursor = 'grab';
                    }
                    dragging = null;

                    // Clear any pending update and apply final update
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                        updateTimeout = null;
                    }
                    applyFilters();
                }
            }

            function updateSliderPositions() {
                // Calculate percentages, treating today as the max
                const startPercent = dateRangeValues.start.getTime() >= today.getTime() ? 1 :
                    (dateRangeValues.start.getTime() - minDate.getTime()) / (maxDate.getTime() - minDate.getTime());

                const endPercent = dateRangeValues.end.getTime() >= today.getTime() ? 1 :
                    (dateRangeValues.end.getTime() - minDate.getTime()) / (maxDate.getTime() - minDate.getTime());

                handleStart.style.left = `${Math.min(startPercent * 100, 100)}%`;
                handleEnd.style.left = `${Math.min(endPercent * 100, 100)}%`;

                track.style.left = `${Math.min(startPercent * 100, 100)}%`;
                track.style.width = `${Math.min((endPercent - startPercent) * 100, 100 - startPercent * 100)}%`;

                // Update labels
                document.getElementById('date-range-start').textContent = dateRangeValues.start.toLocaleDateString();
                document.getElementById('date-range-end').textContent =
                    dateRangeValues.end.getTime() >= today.getTime() ? 'Today' : dateRangeValues.end.toLocaleDateString();
            }

            // Add event listeners for handles
            handleStart.addEventListener('mousedown', (e) => startDrag(e, handleStart));
            handleEnd.addEventListener('mousedown', (e) => startDrag(e, handleEnd));

            // Add event listener for track dragging
            track.addEventListener('mousedown', (e) => startDrag(e, track));

            // Global drag events
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);

            // Touch support
            handleStart.addEventListener('touchstart', (e) => startDrag(e.touches[0], handleStart));
            handleEnd.addEventListener('touchstart', (e) => startDrag(e.touches[0], handleEnd));
            track.addEventListener('touchstart', (e) => startDrag(e.touches[0], track));
            document.addEventListener('touchmove', (e) => e.touches[0] && drag(e.touches[0]));
            document.addEventListener('touchend', stopDrag);

            // Add Quarterly button functionality
            const quarterlyBtn = document.getElementById('quarterly-btn');
            if (quarterlyBtn) {
                quarterlyBtn.addEventListener('click', () => {
                    // Set to 90 days from the current end date
                    const endDate = dateRangeValues.end.getTime() >= today.getTime() ? today : dateRangeValues.end;
                    const startDate = new Date(endDate.getTime() - (90 * 24 * 60 * 60 * 1000)); // 90 days back

                    // Ensure start date doesn't go before minDate
                    if (startDate.getTime() < minDate.getTime()) {
                        dateRangeValues.start = minDate;
                        dateRangeValues.end = new Date(minDate.getTime() + (90 * 24 * 60 * 60 * 1000));
                    } else {
                        dateRangeValues.start = startDate;
                        dateRangeValues.end = endDate;
                    }

                    updateSliderPositions();
                    applyFilters();
                });
            }
        }

        function applyFilters() {
            const selectedUser = document.getElementById('dashboard-filter-user').value;
            const selectedRepo = document.getElementById('dashboard-filter-repo').value;
            updateDashboard(globalData, selectedUser, selectedRepo, dateRangeValues);
        }

        function populateFilters(data) {
            // Get unique users and repositories
            const users = [...new Set(data.allPRs.map(pr => pr.user))].sort();
            const repos = [...new Set(data.allPRs.map(pr => pr.repository))].sort();

            // Populate user filter
            const userSelect = document.getElementById('dashboard-filter-user');
            userSelect.innerHTML = '<option value="">All Users</option>';
            users.forEach(user => {
                const option = document.createElement('option');
                option.value = user;
                option.textContent = user;
                userSelect.appendChild(option);
            });

            // Populate repository filter
            const repoSelect = document.getElementById('dashboard-filter-repo');
            repoSelect.innerHTML = '<option value="">All Repositories</option>';
            repos.forEach(repo => {
                const option = document.createElement('option');
                option.value = repo;
                option.textContent = repo;
                repoSelect.appendChild(option);
            });

            // Create date range slider
            createDateRangeSlider(data);

            // Add auto-apply on change for dropdowns
            userSelect.addEventListener('change', applyFilters);
            repoSelect.addEventListener('change', applyFilters);

            // Add event listener for reset button
            document.getElementById('reset-filters').addEventListener('click', () => {
                document.getElementById('dashboard-filter-user').value = '';
                document.getElementById('dashboard-filter-repo').value = '';

                // Reset date range to full range (up to today)
                const dates = data.allPRs.map(pr => new Date(pr.created_at).getTime());
                const resetToday = new Date();
                resetToday.setHours(23, 59, 59, 999);
                dateRangeValues.start = new Date(Math.min(...dates));
                dateRangeValues.end = resetToday;
                createDateRangeSlider(data);

                updateDashboard(globalData);
            });
        }

        function formatDuration(days) {
            if (days < 0.042) { // Less than 1 hour
                return (days * 24 * 60).toFixed(0) + ' min';
            } else if (days < 1) {
                return (days * 24).toFixed(1) + ' hrs';
            } else if (days < 7) {
                return days.toFixed(1) + ' days';
            } else if (days < 30) {
                return (days / 7).toFixed(1) + ' wks';
            } else {
                return (days / 30).toFixed(1) + ' mos';
            }
        }

        function getPerformanceColorClass(days) {
            // Color breakpoints: <8h (0.33 days), <1 day, <3 days, <1 week (7 days)
            if (days < 0.33) {
                return 'success';  // Green: Less than 8 hours
            } else if (days < 1) {
                return '';  // Default: 8 hours to 1 day
            } else if (days < 3) {
                return 'warning';  // Yellow: 1 to 3 days
            } else {
                return 'danger';  // Red: More than 3 days
            }
        }

        function calculateStats(prs) {
            const totalPRs = prs.length;
            const mergedPRs = prs.filter(pr => pr.merged_at);
            const openPRs = prs.filter(pr => pr.state === 'open');
            const closedPRs = prs.filter(pr => !pr.merged_at && pr.state === 'closed');

            const mergeRate = totalPRs > 0 ? (mergedPRs.length / totalPRs * 100) : 0;

            // Calculate merge times
            const mergedWithTime = mergedPRs.filter(pr => pr.timeToMerge !== null);
            const avgMergeTime = mergedWithTime.length > 0
                ? mergedWithTime.reduce((sum, pr) => sum + pr.timeToMerge, 0) / mergedWithTime.length
                : 0;

            // Get unique contributors and repositories
            const contributors = new Set(prs.map(pr => pr.user));
            const repositories = new Set(prs.map(pr => pr.repository));

            return {
                totalPRs,
                mergedCount: mergedPRs.length,
                openCount: openPRs.length,
                closedCount: closedPRs.length,
                mergeRate,
                avgMergeTime,
                mergedWithTime,
                contributorCount: contributors.size,
                repoCount: repositories.size
            };
        }

        function updateDashboard(data, filterUser = '', filterRepo = '', dateRange = null) {
            // Filter PRs based on user, repo, and date range
            let filteredPRs = data.allPRs;
            if (filterUser) {
                filteredPRs = filteredPRs.filter(pr => pr.user === filterUser);
            }
            if (filterRepo) {
                filteredPRs = filteredPRs.filter(pr => pr.repository === filterRepo);
            }
            if (dateRange && dateRange.start && dateRange.end) {
                filteredPRs = filteredPRs.filter(pr => {
                    const prDate = new Date(pr.created_at);
                    // Left inclusive (>=), right exclusive (<)
                    return prDate >= dateRange.start && prDate < dateRange.end;
                });
            }

            // Calculate stats for filtered PRs
            const stats = calculateStats(filteredPRs);

            // Update overview stats
            document.getElementById('total-prs').textContent = stats.totalPRs.toLocaleString();
            document.getElementById('merge-rate').textContent = stats.mergeRate.toFixed(2) + '%';
            document.getElementById('avg-merge-time').textContent = stats.avgMergeTime.toFixed(2) + ' days';
            document.getElementById('merged-count').textContent = stats.mergedCount.toLocaleString();
            document.getElementById('open-count').textContent = stats.openCount.toLocaleString();
            document.getElementById('closed-count').textContent = stats.closedCount.toLocaleString();
            document.getElementById('active-contributors').textContent = stats.contributorCount;
            document.getElementById('repo-count').textContent = stats.repoCount;

            // Calculate merge time statistics
            if (stats.mergedWithTime.length > 0) {
                const mergeTimes = stats.mergedWithTime.map(pr => pr.timeToMerge).sort((a, b) => a - b);
                const count = mergeTimes.length;

                // Calculate percentiles
                const p25Index = Math.floor(count * 0.25);
                const medianIndex = Math.floor(count * 0.5);
                const p75Index = Math.floor(count * 0.75);
                const p90Index = Math.floor(count * 0.9);
                const p95Index = Math.floor(count * 0.95);

                // Update values with dynamic colors
                const fastestEl = document.getElementById('fastest-merge');
                fastestEl.textContent = formatDuration(mergeTimes[0]);
                fastestEl.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[0]);

                const p25El = document.getElementById('p25-merge');
                p25El.textContent = formatDuration(mergeTimes[p25Index]);
                p25El.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[p25Index]);

                const medianEl = document.getElementById('median-merge-time');
                medianEl.textContent = formatDuration(mergeTimes[medianIndex]);
                medianEl.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[medianIndex]);

                const p75El = document.getElementById('p75-merge');
                p75El.textContent = formatDuration(mergeTimes[p75Index]);
                p75El.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[p75Index]);

                const p90El = document.getElementById('p90-merge');
                p90El.textContent = formatDuration(mergeTimes[p90Index]);
                p90El.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[p90Index]);

                const p95El = document.getElementById('p95-merge');
                p95El.textContent = formatDuration(mergeTimes[p95Index]);
                p95El.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[p95Index]);

                const slowestEl = document.getElementById('slowest-merge');
                slowestEl.textContent = formatDuration(mergeTimes[count - 1]);
                slowestEl.className = 'metric-value ' + getPerformanceColorClass(mergeTimes[count - 1]);
            } else {
                document.getElementById('fastest-merge').textContent = '-';
                document.getElementById('p25-merge').textContent = '-';
                document.getElementById('median-merge-time').textContent = '-';
                document.getElementById('p75-merge').textContent = '-';
                document.getElementById('p90-merge').textContent = '-';
                document.getElementById('p95-merge').textContent = '-';
                document.getElementById('slowest-merge').textContent = '-';
            }

            // Update repository list in important note (use original data)
            if (data.repoStats && data.repoStats.length > 0) {
                const repoNames = data.repoStats.map(repo => repo.repository).join(', ');
                document.getElementById('repo-list').textContent = repoNames;
            }
        }

        function renderCharts(data) {
            renderMemberChart(data.memberStats);
            renderRepoTimeChart(data.repoStats);
            renderQuarterlyChart(data.quarterlyStats);
            renderStatusPieChart(data.summary, data.memberStats);
            renderDistributionHistogram(data.memberStats);
            renderMemberBoxplot(data.memberStats);
            renderMemberDetailsTable(data.memberStats);
            renderGanttChart(data.allPRs || []);
        }

        function renderMemberChart(memberStats) {
            const container = d3.select("#member-chart");
            container.selectAll("*").remove();

            const margin = {top: 20, right: 30, bottom: 100, left: 60};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = container
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Sort by total PRs
            memberStats.sort((a, b) => b.totalPRs - a.totalPRs);

            const x = d3.scaleBand()
                .range([0, width])
                .domain(memberStats.map(d => d.member))
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(memberStats, d => d.totalPRs)])
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(['merged', 'open', 'closed'])
                .range(['#28a745', '#ffc107', '#dc3545']);

            // Stack the data
            const stack = d3.stack()
                .keys(['merged', 'open', 'closed']);

            const stackedData = stack(memberStats);

            // Add bars
            g.selectAll(".series")
                .data(stackedData)
                .enter().append("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                .data(d => d)
                .enter().append("rect")
                .attr("x", d => x(d.data.member))
                .attr("y", d => y(d[1]))
                .attr("height", d => y(d[0]) - y(d[1]))
                .attr("width", x.bandwidth())
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    const key = d3.select(this.parentNode).datum().key;
                    tooltip.html(`${d.data.member}<br/>${key}: ${d[1] - d[0]}`)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add X axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            // Add Y axis
            g.append("g")
                .call(d3.axisLeft(y));

            // Add Y axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Number of PRs");

            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width - 100}, 20)`);

            const legendItems = ['merged', 'open', 'closed'];
            legendItems.forEach((item, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);

                legendRow.append("rect")
                    .attr("width", 16)
                    .attr("height", 16)
                    .attr("fill", color(item));

                legendRow.append("text")
                    .attr("x", 20)
                    .attr("y", 12)
                    .style("font-size", "12px")
                    .text(item.charAt(0).toUpperCase() + item.slice(1));
            });
        }

        function renderRepoTimeChart(repoStats) {
            const container = d3.select("#repo-time-chart");
            container.selectAll("*").remove();

            const margin = {top: 20, right: 30, bottom: 60, left: 100};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Sort by average time
            repoStats.sort((a, b) => a.avgTime - b.avgTime);

            const x = d3.scaleLinear()
                .domain([0, d3.max(repoStats, d => d.avgTime)])
                .range([0, width]);

            const y = d3.scaleBand()
                .range([0, height])
                .domain(repoStats.map(d => d.repository))
                .padding(0.1);

            // Add bars
            g.selectAll(".bar")
                .data(repoStats)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", 0)
                .attr("y", d => y(d.repository))
                .attr("width", d => x(d.avgTime))
                .attr("height", y.bandwidth())
                .attr("fill", "#007bff")
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`${d.repository}<br/>Avg: ${d.avgTime.toFixed(1)} days<br/>Median: ${d.medianTime.toFixed(1)} days`)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add value labels
            g.selectAll(".text")
                .data(repoStats)
                .enter().append("text")
                .attr("x", d => x(d.avgTime) + 5)
                .attr("y", d => y(d.repository) + y.bandwidth() / 2)
                .attr("dy", ".35em")
                .style("font-size", "12px")
                .text(d => d.avgTime.toFixed(1) + " days");

            // Add X axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y axis
            g.append("g")
                .call(d3.axisLeft(y));

            // Add X axis label
            g.append("text")
                .attr("transform", `translate(${width/2}, ${height + margin.bottom})`)
                .style("text-anchor", "middle")
                .text("Average Days to Merge");
        }

        function renderQuarterlyChart(quarterlyStats) {
            const container = d3.select("#quarterly-chart");
            container.selectAll("*").remove();

            const margin = {top: 20, right: 80, bottom: 60, left: 60};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;

            const svg = container
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Calculate candlestick data from member stats
            const candlestickData = quarterlyStats.map(q => {
                // Get all merge times for this quarter
                const mergedPRs = globalData.allPRs.filter(pr => {
                    if (!pr.merged_at || !pr.timeToMerge) return false;
                    const prDate = new Date(pr.created_at);
                    const quarter = Math.floor(prDate.getMonth() / 3) + 1;
                    const year = prDate.getFullYear();
                    const quarterString = `${year} Q${quarter}`;
                    return quarterString === q.quarter;
                });

                if (mergedPRs.length === 0) {
                    return {
                        quarter: q.quarter,
                        min: 0,
                        q1: 0,
                        median: 0,
                        q3: 0,
                        max: 0,
                        total: q.total,
                        merged: q.merged,
                        avgTime: q.avgTime
                    };
                }

                const times = mergedPRs.map(pr => pr.timeToMerge).sort((a, b) => a - b);
                const len = times.length;

                return {
                    quarter: q.quarter,
                    min: times[0],
                    q1: times[Math.floor(len * 0.25)],
                    median: times[Math.floor(len * 0.5)],
                    q3: times[Math.floor(len * 0.75)],
                    max: times[len - 1],
                    total: q.total,
                    merged: q.merged,
                    avgTime: q.avgTime
                };
            });

            const x = d3.scaleBand()
                .range([0, width])
                .domain(candlestickData.map(d => d.quarter))
                .padding(0.3);

            // Calculate y domain based on min/max of all data points (filter out zeros for log scale)
            const allValues = candlestickData.flatMap(d => [d.min, d.q1, d.median, d.q3, d.max]).filter(v => v > 0);
            const yDomain = [Math.max(0.01, Math.min(...allValues) * 0.9), Math.max(...allValues) * 1.1];

            const y = d3.scaleLog()
                .domain(yDomain)
                .range([height, 0])
                .clamp(true);

            // Draw candlesticks
            const candleWidth = x.bandwidth() * 0.5;

            candlestickData.forEach(d => {
                const xPos = x(d.quarter) + x.bandwidth() / 2;

                // Draw whisker lines (min to max)
                g.append("line")
                    .attr("x1", xPos)
                    .attr("x2", xPos)
                    .attr("y1", y(d.max))
                    .attr("y2", y(d.min))
                    .attr("stroke", "#999")
                    .attr("stroke-width", 1);

                // Draw min whisker cap
                g.append("line")
                    .attr("x1", xPos - candleWidth / 4)
                    .attr("x2", xPos + candleWidth / 4)
                    .attr("y1", y(d.min))
                    .attr("y2", y(d.min))
                    .attr("stroke", "#999")
                    .attr("stroke-width", 1);

                // Draw max whisker cap
                g.append("line")
                    .attr("x1", xPos - candleWidth / 4)
                    .attr("x2", xPos + candleWidth / 4)
                    .attr("y1", y(d.max))
                    .attr("y2", y(d.max))
                    .attr("stroke", "#999")
                    .attr("stroke-width", 1);

                // Draw box (Q1 to Q3)
                const boxHeight = Math.abs(y(d.q1) - y(d.q3));
                const boxY = Math.min(y(d.q1), y(d.q3));

                g.append("rect")
                    .attr("x", xPos - candleWidth / 2)
                    .attr("y", boxY)
                    .attr("width", candleWidth)
                    .attr("height", boxHeight)
                    .attr("fill", d.median < d.avgTime ? "#4CAF50" : "#FF5252")
                    .attr("fill-opacity", 0.7)
                    .attr("stroke", "#333")
                    .attr("stroke-width", 1);

                // Draw median line
                g.append("line")
                    .attr("x1", xPos - candleWidth / 2)
                    .attr("x2", xPos + candleWidth / 2)
                    .attr("y1", y(d.median))
                    .attr("y2", y(d.median))
                    .attr("stroke", "#333")
                    .attr("stroke-width", 2);

                // Add hover area
                g.append("rect")
                    .attr("x", xPos - candleWidth / 2)
                    .attr("y", y(d.max))
                    .attr("width", candleWidth)
                    .attr("height", y(d.min) - y(d.max))
                    .attr("fill", "transparent")
                    .on("mouseover", function(event) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`
                            <strong>${d.quarter}</strong><br/>
                            Total PRs: ${d.total}<br/>
                            Merged: ${d.merged}<br/>
                            <hr style="margin: 5px 0; border: none; border-top: 1px solid #ccc;">
                            <strong>Merge Time (days):</strong><br/>
                            Max: ${d.max.toFixed(2)}<br/>
                            Q3: ${d.q3.toFixed(2)}<br/>
                            Median: ${d.median.toFixed(2)}<br/>
                            Q1: ${d.q1.toFixed(2)}<br/>
                            Min: ${d.min.toFixed(2)}<br/>
                            Average: ${d.avgTime.toFixed(2)}
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
            });

            // Add X axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("text-anchor", "middle");

            // Add Y axis with log scale formatting
            g.append("g")
                .call(d3.axisLeft(y)
                    .tickFormat(d => {
                        if (d < 1) return (d * 24).toFixed(0) + "h";
                        else if (d < 7) return d.toFixed(0) + "d";
                        else return (d / 7).toFixed(1) + "w";
                    })
                    .tickValues([0.125, 0.25, 0.5, 1, 2, 3, 7, 14, 30, 60, 120]));

            // Add Y axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Merge Time (log scale)");

            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width - 100}, 20)`);

            // Legend items
            const legendData = [
                { label: "Max", y: 0 },
                { label: "Q3", y: 20 },
                { label: "Median", y: 40 },
                { label: "Q1", y: 60 },
                { label: "Min", y: 80 }
            ];

            legendData.forEach(item => {
                legend.append("text")
                    .attr("x", 0)
                    .attr("y", item.y)
                    .style("font-size", "11px")
                    .text(item.label);

                if (item.label === "Median") {
                    legend.append("line")
                        .attr("x1", 35)
                        .attr("x2", 50)
                        .attr("y1", item.y - 4)
                        .attr("y2", item.y - 4)
                        .attr("stroke", "#333")
                        .attr("stroke-width", 2);
                } else {
                    legend.append("line")
                        .attr("x1", 35)
                        .attr("x2", 50)
                        .attr("y1", item.y - 4)
                        .attr("y2", item.y - 4)
                        .attr("stroke", "#999")
                        .attr("stroke-width", 1);
                }
            });

            // Draw sample candlestick
            const sampleX = 42;
            const sampleWidth = 16;

            legend.append("line")
                .attr("x1", sampleX + sampleWidth / 2)
                .attr("x2", sampleX + sampleWidth / 2)
                .attr("y1", -4)
                .attr("y2", 76)
                .attr("stroke", "#999")
                .attr("stroke-width", 1);

            legend.append("rect")
                .attr("x", sampleX)
                .attr("y", 16)
                .attr("width", sampleWidth)
                .attr("height", 40)
                .attr("fill", "#4CAF50")
                .attr("fill-opacity", 0.7)
                .attr("stroke", "#333")
                .attr("stroke-width", 1);
        }

        function renderStatusPieChart(summary, memberStats) {
            // Render overall pie chart
            const container = d3.select("#status-pie-chart");
            container.selectAll("*").remove();

            const width = 400;
            const height = 300;
            const radius = Math.min(width, height) / 2;

            const svg = container
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2}, ${height / 2})`);

            const data = [
                { label: "Merged", value: summary.mergedPRs, color: "#28a745" },
                { label: "Open", value: summary.openPRs, color: "#ffc107" },
                { label: "Closed", value: summary.closedPRs, color: "#dc3545" }
            ];

            const pie = d3.pie()
                .value(d => d.value);

            const arc = d3.arc()
                .innerRadius(radius * 0.5)
                .outerRadius(radius * 0.8);

            const outerArc = d3.arc()
                .innerRadius(radius * 0.9)
                .outerRadius(radius * 0.9);

            const arcs = svg.selectAll(".arc")
                .data(pie(data))
                .enter().append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    const percent = ((d.data.value / summary.totalPRs) * 100).toFixed(1);
                    tooltip.html(`${d.data.label}: ${d.data.value}<br/>${percent}%`)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add labels
            arcs.append("text")
                .attr("transform", d => {
                    const pos = outerArc.centroid(d);
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                    pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
                    return `translate(${pos})`;
                })
                .style("text-anchor", d => {
                    const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                    return (midangle < Math.PI ? 'start' : 'end');
                })
                .text(d => `${d.data.label}: ${d.data.value}`);

            // Add center text
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "-0.2em")
                .style("font-size", "24px")
                .style("font-weight", "bold")
                .text(summary.totalPRs);

            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "1.2em")
                .style("font-size", "14px")
                .text("Total PRs");

            // Render member breakdown charts
            const memberContainer = d3.select("#member-status-charts");
            memberContainer.selectAll("*").remove();

            // Sort members by total PRs and take top contributors
            const topMembers = memberStats
                .filter(member => member.totalPRs > 0)
                .sort((a, b) => b.totalPRs - a.totalPRs)
                .slice(0, 8); // Show top 8 members

            const memberWidth = 180;
            const memberHeight = 140;
            const memberRadius = Math.min(memberWidth, memberHeight) / 2 - 10;

            topMembers.forEach(member => {
                const memberDiv = memberContainer
                    .append("div")
                    .style("text-align", "center");

                const memberSvg = memberDiv
                    .append("svg")
                    .attr("width", memberWidth)
                    .attr("height", memberHeight)
                    .append("g")
                    .attr("transform", `translate(${memberWidth / 2}, ${memberHeight / 2})`);

                const memberData = [
                    { label: "Merged", value: member.merged, color: "#28a745" },
                    { label: "Open", value: member.open, color: "#ffc107" },
                    { label: "Closed", value: member.closed, color: "#dc3545" }
                ].filter(d => d.value > 0); // Only show non-zero values

                if (memberData.length === 0) return;

                const memberPie = d3.pie().value(d => d.value);
                const memberArc = d3.arc()
                    .innerRadius(0)
                    .outerRadius(memberRadius);

                const memberArcs = memberSvg.selectAll(".member-arc")
                    .data(memberPie(memberData))
                    .enter().append("g")
                    .attr("class", "member-arc");

                memberArcs.append("path")
                    .attr("d", memberArc)
                    .attr("fill", d => d.data.color)
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        const percent = ((d.data.value / member.totalPRs) * 100).toFixed(1);
                        tooltip.html(`${member.member}<br/>${d.data.label}: ${d.data.value}<br/>${percent}%`)
                            .style("left", (event.pageX) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // Add member name and total
                memberDiv.append("div")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("margin-top", "5px")
                    .text(member.member);

                memberDiv.append("div")
                    .style("font-size", "10px")
                    .style("color", "#666")
                    .text(`${member.totalPRs} PRs`);
            });
        }

        function renderMemberDetailsTable(memberStats) {
            const container = document.getElementById('member-details-table');

            // Sort by total PRs descending
            const sortedStats = [...memberStats].sort((a, b) => b.totalPRs - a.totalPRs);

            let tableHTML = `
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Member</th>
                            <th class="number">Total PRs</th>
                            <th class="number">Merged</th>
                            <th class="number">Open</th>
                            <th class="number">Closed</th>
                            <th class="number">Merge Rate</th>
                            <th class="number">Avg Time</th>
                            <th class="number">Median</th>
                            <th class="number">P75</th>
                            <th class="number">P95</th>
                            <th class="number">StdDev</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            sortedStats.forEach((stat, index) => {
                const mergeRate = stat.totalPRs > 0 ? (stat.merged / stat.totalPRs * 100) : 0;
                tableHTML += `
                    <tr class="expandable-row" onclick="toggleMemberDetails(${index})">
                        <td><strong>${stat.member}</strong></td>
                        <td class="number">${stat.totalPRs.toLocaleString()}</td>
                        <td class="number">${stat.merged.toLocaleString()}</td>
                        <td class="number">${stat.open.toLocaleString()}</td>
                        <td class="number">${stat.closed.toLocaleString()}</td>
                        <td class="number">${mergeRate.toFixed(1)}%</td>
                        <td class="number">${stat.avgTime.toFixed(1)} days</td>
                        <td class="number">${stat.medianTime.toFixed(1)} days</td>
                        <td class="number">${(stat.p75 || 0).toFixed(1)} days</td>
                        <td class="number">${(stat.p95 || 0).toFixed(1)} days</td>
                        <td class="number">${(stat.stdDev || 0).toFixed(1)} days</td>
                        <td>üìä Click for details</td>
                    </tr>
                    <tr class="detail-row" id="detail-${index}">
                        <td colspan="12">
                            <div class="detail-content">
                                <div class="repo-breakdown">
                                    <div class="breakdown-title">By Repository:</div>
                                    ${stat.repoStats ? stat.repoStats.map(repo => `
                                        <div class="breakdown-item">
                                            <strong>${repo.repository}:</strong> ${repo.totalPRs} PRs
                                            (${repo.mergedPRs} merged, ${repo.openPRs} open, ${repo.closedNotMerged} closed)
                                            ${repo.avgTimeToMerge !== null ? `- Avg: ${repo.avgTimeToMerge.toFixed(1)} days` : ''}
                                        </div>
                                    `).join('') : 'No repository breakdown available'}
                                </div>
                                <div class="quarter-breakdown">
                                    <div class="breakdown-title">By Quarter:</div>
                                    ${stat.quarterlyStats ? stat.quarterlyStats.map(q => `
                                        <div class="breakdown-item">
                                            <strong>${q.quarter}:</strong> ${q.totalPRs} PRs
                                            (${q.mergedPRs} merged, ${q.openPRs} open, ${q.closedNotMerged} closed)
                                            ${q.avgTimeToMerge !== null ? `- Avg: ${q.avgTimeToMerge.toFixed(1)} days` : ''}
                                        </div>
                                    `).join('') : 'No quarterly breakdown available'}
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHTML;
        }

        function renderDistributionHistogram(memberStats) {
            const container = d3.select("#distribution-histogram");
            container.selectAll("*").remove();

            const margin = {top: 20, right: 30, bottom: 60, left: 60};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = container
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Combine all distributions
            let allTimes = [];
            memberStats.forEach(stat => {
                if (stat.distribution && stat.distribution.length > 0) {
                    allTimes = allTimes.concat(stat.distribution);
                }
            });

            if (allTimes.length === 0) return;

            // Create histogram data
            const maxTime = Math.min(d3.max(allTimes), 30); // Cap at 30 days for better visualization
            const numBins = Math.min(50, Math.ceil(Math.sqrt(allTimes.length)));

            const x = d3.scaleLinear()
                .domain([0, maxTime])
                .range([0, width]);

            const histogram = d3.histogram()
                .value(d => Math.min(d, maxTime))
                .domain(x.domain())
                .thresholds(x.ticks(numBins));

            const bins = histogram(allTimes);

            const y = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([height, 0]);

            // Add bars
            g.selectAll(".bar")
                .data(bins)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.x0))
                .attr("width", d => x(d.x1) - x(d.x0) - 1)
                .attr("y", d => y(d.length))
                .attr("height", d => height - y(d.length))
                .attr("fill", "#4CAF50")
                .on("mouseover", function(event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`${d.x0.toFixed(1)}-${d.x1.toFixed(1)} days<br/>${d.length} PRs`)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add X axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add Y axis
            g.append("g")
                .call(d3.axisLeft(y));

            // Add X axis label
            g.append("text")
                .attr("transform", `translate(${width/2}, ${height + margin.bottom})`)
                .style("text-anchor", "middle")
                .text("Merge Time (days)");

            // Add Y axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Number of PRs");

            // Add statistics text
            const mean = allTimes.reduce((sum, t) => sum + t, 0) / allTimes.length;
            const sortedTimes = [...allTimes].sort((a, b) => a - b);
            const median = sortedTimes.length % 2 === 0
                ? (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2
                : sortedTimes[Math.floor(sortedTimes.length / 2)];

            g.append("text")
                .attr("x", width - 10)
                .attr("y", 20)
                .style("text-anchor", "end")
                .style("font-size", "12px")
                .text(`Mean: ${mean.toFixed(1)} days, Median: ${median.toFixed(1)} days`);
        }

        function renderMemberBoxplot(memberStats) {
            const container = d3.select("#member-boxplot");
            container.selectAll("*").remove();

            const margin = {top: 20, right: 30, bottom: 100, left: 100};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const svg = container
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Filter members with distribution data and sort by median
            const membersWithData = memberStats
                .filter(stat => stat.distribution && stat.distribution.length > 0)
                .map(stat => ({
                    ...stat,
                    sortedTimes: [...stat.distribution].sort((a, b) => a - b)
                }))
                .sort((a, b) => a.medianTime - b.medianTime);

            if (membersWithData.length === 0) return;

            const y = d3.scaleBand()
                .range([0, height])
                .domain(membersWithData.map(d => d.member))
                .padding(0.1);

            // Get all values for determining domain (filter out zeros for log scale)
            const allValues = membersWithData.flatMap(d => [d.min, d.p25, d.medianTime, d.p75, d.p90, d.p95, d.max].filter(v => v && v > 0));
            const xDomain = [Math.max(0.01, Math.min(...allValues) * 0.9), Math.max(...allValues) * 1.1];

            const x = d3.scaleLog()
                .domain(xDomain)
                .range([0, width])
                .clamp(true);

            // Draw box plots
            membersWithData.forEach(stat => {
                const yPos = y(stat.member) + y.bandwidth() / 2;
                const boxHeight = y.bandwidth() * 0.6;

                // Box (Q1 to Q3)
                g.append("rect")
                    .attr("x", x(stat.p25))
                    .attr("y", yPos - boxHeight / 2)
                    .attr("width", x(stat.p75) - x(stat.p25))
                    .attr("height", boxHeight)
                    .attr("fill", "lightblue")
                    .attr("stroke", "black")
                    .on("mouseover", function(event) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`${stat.member}<br/>
                            Min: ${stat.min.toFixed(1)} days<br/>
                            Q1: ${stat.p25.toFixed(1)} days<br/>
                            Median: ${stat.medianTime.toFixed(1)} days<br/>
                            Q3: ${stat.p75.toFixed(1)} days<br/>
                            P95: ${stat.p95.toFixed(1)} days<br/>
                            Max: ${stat.max.toFixed(1)} days<br/>
                            StdDev: ${stat.stdDev.toFixed(1)} days`)
                            .style("left", (event.pageX) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // Median line
                g.append("line")
                    .attr("x1", x(stat.medianTime))
                    .attr("x2", x(stat.medianTime))
                    .attr("y1", yPos - boxHeight / 2)
                    .attr("y2", yPos + boxHeight / 2)
                    .attr("stroke", "black")
                    .attr("stroke-width", 2);

                // Whiskers
                const whiskerLength = boxHeight * 0.3;

                // Left whisker
                g.append("line")
                    .attr("x1", x(stat.min))
                    .attr("x2", x(stat.p25))
                    .attr("y1", yPos)
                    .attr("y2", yPos)
                    .attr("stroke", "black")
                    .attr("stroke-width", 1.5);

                g.append("line")
                    .attr("x1", x(stat.min))
                    .attr("x2", x(stat.min))
                    .attr("y1", yPos - whiskerLength)
                    .attr("y2", yPos + whiskerLength)
                    .attr("stroke", "black")
                    .attr("stroke-width", 1.5);

                // Right whisker
                g.append("line")
                    .attr("x1", x(stat.p75))
                    .attr("x2", x(stat.max))
                    .attr("y1", yPos)
                    .attr("y2", yPos)
                    .attr("stroke", "black")
                    .attr("stroke-width", 1.5);

                g.append("line")
                    .attr("x1", x(stat.max))
                    .attr("x2", x(stat.max))
                    .attr("y1", yPos - whiskerLength)
                    .attr("y2", yPos + whiskerLength)
                    .attr("stroke", "black")
                    .attr("stroke-width", 1.5);
            });

            // Add X axis with log scale formatting
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .tickFormat(d => {
                        if (d < 1) return (d * 24).toFixed(0) + "h";
                        else if (d < 7) return d.toFixed(0) + "d";
                        else return (d / 7).toFixed(1) + "w";
                    })
                    .tickValues([0.125, 0.25, 0.5, 1, 2, 3, 7, 14, 30, 60, 120]));

            // Add Y axis
            g.append("g")
                .call(d3.axisLeft(y));

            // Add X axis label
            g.append("text")
                .attr("transform", `translate(${width/2}, ${height + margin.bottom})`)
                .style("text-anchor", "middle")
                .text("Merge Time (log scale)");
        }

        function toggleMemberDetails(index) {
            const detailRow = document.getElementById(`detail-${index}`);
            detailRow.classList.toggle('expanded');
        }


        let ganttDateRangeValues = { start: null, end: null };

        function createGanttDateRangeSlider(allPRs) {
            // Get date range from data
            const dates = allPRs.map(pr => new Date(pr.created_at).getTime());
            const minDate = new Date(Math.min(...dates));
            const today = new Date();
            today.setHours(23, 59, 59, 999);

            // Initialize with full range
            ganttDateRangeValues.start = minDate;
            ganttDateRangeValues.end = today;

            const container = document.getElementById('gantt-date-range-slider');
            container.innerHTML = '';

            // Create slider elements
            const slider = document.createElement('div');
            slider.className = 'range-slider';

            const track = document.createElement('div');
            track.className = 'range-slider-track';

            const handleStart = document.createElement('div');
            handleStart.className = 'range-slider-handle';
            handleStart.id = 'gantt-handle-start';

            const handleEnd = document.createElement('div');
            handleEnd.className = 'range-slider-handle';
            handleEnd.id = 'gantt-handle-end';

            slider.appendChild(track);
            slider.appendChild(handleStart);
            slider.appendChild(handleEnd);
            container.appendChild(slider);

            // Update positions
            updateGanttSliderPositions();

            // Add drag functionality
            let dragging = null;
            let dragStartX = 0;
            let originalStartDate = null;
            let originalEndDate = null;
            let updateTimeout = null;

            // Throttle function for updates
            function throttledUpdateGantt() {
                if (updateTimeout) return;
                updateTimeout = setTimeout(() => {
                    updateGanttChart(allPRs);
                    updateTimeout = null;
                }, 100);
            }

            function updateGanttSliderPositions() {
                const range = today.getTime() - minDate.getTime();
                const startPos = ((ganttDateRangeValues.start.getTime() - minDate.getTime()) / range) * 100;
                const endPos = ((ganttDateRangeValues.end.getTime() - minDate.getTime()) / range) * 100;

                handleStart.style.left = `${startPos}%`;
                handleEnd.style.left = `${endPos}%`;
                track.style.left = `${startPos}%`;
                track.style.width = `${endPos - startPos}%`;

                // Update display
                document.getElementById('gantt-date-start').textContent = ganttDateRangeValues.start.toLocaleDateString();
                document.getElementById('gantt-date-end').textContent = ganttDateRangeValues.end.toLocaleDateString();
            }

            // Handle dragging
            function handleMouseDown(e, handle, isTrack = false) {
                e.preventDefault();
                dragging = isTrack ? 'track' : handle;
                dragStartX = e.clientX || e.touches[0].clientX;
                originalStartDate = new Date(ganttDateRangeValues.start);
                originalEndDate = new Date(ganttDateRangeValues.end);
                document.body.style.cursor = 'grabbing';
            }

            function handleMouseMove(e) {
                if (!dragging) return;

                const currentX = e.clientX || e.touches[0].clientX;
                const deltaX = currentX - dragStartX;
                const sliderWidth = slider.offsetWidth;
                const range = today.getTime() - minDate.getTime();
                const timeDelta = (deltaX / sliderWidth) * range;

                if (dragging === 'track') {
                    // Move both handles together
                    const newStart = new Date(originalStartDate.getTime() + timeDelta);
                    const newEnd = new Date(originalEndDate.getTime() + timeDelta);
                    const interval = originalEndDate.getTime() - originalStartDate.getTime();

                    if (newStart >= minDate && newEnd <= today) {
                        ganttDateRangeValues.start = newStart;
                        ganttDateRangeValues.end = newEnd;
                    } else if (newStart < minDate) {
                        ganttDateRangeValues.start = minDate;
                        ganttDateRangeValues.end = new Date(minDate.getTime() + interval);
                    } else if (newEnd > today) {
                        ganttDateRangeValues.end = today;
                        ganttDateRangeValues.start = new Date(today.getTime() - interval);
                    }
                } else if (dragging === 'gantt-handle-start') {
                    const newDate = new Date(originalStartDate.getTime() + timeDelta);
                    if (newDate >= minDate && newDate < ganttDateRangeValues.end) {
                        ganttDateRangeValues.start = newDate;
                    }
                } else if (dragging === 'gantt-handle-end') {
                    const newDate = new Date(originalEndDate.getTime() + timeDelta);
                    if (newDate <= today && newDate > ganttDateRangeValues.start) {
                        ganttDateRangeValues.end = newDate;
                    }
                }

                updateGanttSliderPositions();
                throttledUpdateGantt();
            }

            function handleMouseUp() {
                if (dragging) {
                    dragging = null;
                    document.body.style.cursor = '';
                    updateGanttChart(allPRs);
                }
            }

            // Add event listeners
            handleStart.addEventListener('mousedown', (e) => handleMouseDown(e, 'gantt-handle-start'));
            handleEnd.addEventListener('mousedown', (e) => handleMouseDown(e, 'gantt-handle-end'));
            track.addEventListener('mousedown', (e) => handleMouseDown(e, null, true));

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Touch support
            handleStart.addEventListener('touchstart', (e) => handleMouseDown(e, 'gantt-handle-start'));
            handleEnd.addEventListener('touchstart', (e) => handleMouseDown(e, 'gantt-handle-end'));
            track.addEventListener('touchstart', (e) => handleMouseDown(e, null, true));

            document.addEventListener('touchmove', handleMouseMove, { passive: false });
            document.addEventListener('touchend', handleMouseUp);
        }

        function renderGanttChart(allPRs) {
            const container = d3.select("#gantt-chart");
            container.selectAll("*").remove();

            if (!allPRs || allPRs.length === 0) {
                container.append("p").text("No PR data available for Gantt chart");
                return;
            }

            // Populate filter dropdowns
            const users = [...new Set(allPRs.map(pr => pr.user))].sort();
            const repos = [...new Set(allPRs.map(pr => pr.repository))].sort();

            const userSelect = document.getElementById('gantt-filter-user');
            userSelect.innerHTML = '<option value="">All Users</option>' +
                users.map(user => `<option value="${user}">${user}</option>`).join('');

            const repoSelect = document.getElementById('gantt-filter-repo');
            repoSelect.innerHTML = '<option value="">All Repositories</option>' +
                repos.map(repo => `<option value="${repo}">${repo}</option>`).join('');

            // Create date range slider for Gantt
            createGanttDateRangeSlider(allPRs);

            // Set up event listeners for controls
            ['gantt-sort', 'gantt-filter-user', 'gantt-filter-repo', 'gantt-filter-status'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => updateGanttChart(allPRs));
            });

            // Set up search input with throttling
            let searchTimeout = null;
            const searchInput = document.getElementById('gantt-search-keywords');
            searchInput.addEventListener('input', () => {
                if (searchTimeout) clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    updateGanttChart(allPRs);
                }, 300); // 300ms throttle
            });

            updateGanttChart(allPRs);
        }

        function getRepoOwner(repository) {
            // Map repository names to their GitHub owners
            const repoMap = {
                'ComfyUI': 'comfyanonymous',
                'ComfyUI_frontend': 'Comfy-Org',
                'Frontend': 'Comfy-Org',
                'desktop': 'Comfy-Org',
                'Desktop': 'Comfy-Org',
                'comfy-api': 'Comfy-Org',
                'Comfy-API': 'Comfy-Org',
                'cloud': 'Comfy-Org',
                'Cloud': 'Comfy-Org'
            };
            return repoMap[repository] || 'Comfy-Org';
        }

        function updateGanttChart(allPRs) {
            const container = d3.select("#gantt-chart");
            const statsContainer = document.getElementById('gantt-stats');
            container.select("svg").remove();

            // Get filter and sort values
            const sortBy = document.getElementById('gantt-sort').value;
            const filterUser = document.getElementById('gantt-filter-user').value;
            const filterRepo = document.getElementById('gantt-filter-repo').value;
            const filterStatus = document.getElementById('gantt-filter-status').value;
            const searchKeywords = document.getElementById('gantt-search-keywords').value.trim();

            // Use date range values from slider
            const fromDate = ganttDateRangeValues.start;
            const toDate = ganttDateRangeValues.end;

            // Parse search keywords (split by spaces, filter empty)
            const keywords = searchKeywords ? searchKeywords.toLowerCase().split(/\s+/).filter(k => k.length > 0) : [];

            // Filter PRs
            let filteredPRs = allPRs.filter(pr => {
                if (filterUser && pr.user !== filterUser) return false;
                if (filterRepo && pr.repository !== filterRepo) return false;

                // Handle status filtering with merged vs closed distinction
                if (filterStatus) {
                    const actualState = pr.merged_at ? 'merged' : pr.state;
                    if (actualState !== filterStatus) return false;
                }

                // Filter by date range (inclusive start, exclusive end)
                const prDate = new Date(pr.created_at);
                if (fromDate && prDate < fromDate) return false;
                if (toDate && prDate >= toDate) return false;

                // Filter by keywords (all keywords must match in title)
                if (keywords.length > 0) {
                    const title = pr.title.toLowerCase();
                    const allMatch = keywords.every(keyword => title.includes(keyword));
                    if (!allMatch) return false;
                }

                return true;
            });

            // Sort PRs
            filteredPRs.sort((a, b) => {
                switch (sortBy) {
                    case 'created':
                        return new Date(a.created_at) - new Date(b.created_at);
                    case 'closed':
                        // Sort by closed_at or merged_at date, with open PRs at the end
                        const aClosedDate = a.merged_at || a.closed_at;
                        const bClosedDate = b.merged_at || b.closed_at;

                        if (!aClosedDate && !bClosedDate) {
                            // Both are open, sort by created date
                            return new Date(a.created_at) - new Date(b.created_at);
                        }
                        if (!aClosedDate) return 1; // Open PRs go to the end
                        if (!bClosedDate) return -1; // Open PRs go to the end

                        return new Date(aClosedDate) - new Date(bClosedDate);
                    case 'user':
                        return a.user.localeCompare(b.user);
                    case 'repository':
                        return a.repository.localeCompare(b.repository);
                    case 'duration':
                        const aDuration = a.timeToMerge || (a.state === 'open' ? (Date.now() - new Date(a.created_at)) / (1000 * 60 * 60 * 24) : 0);
                        const bDuration = b.timeToMerge || (b.state === 'open' ? (Date.now() - new Date(b.created_at)) / (1000 * 60 * 60 * 24) : 0);
                        return bDuration - aDuration;
                    case 'status':
                        return a.state.localeCompare(b.state);
                    default:
                        return new Date(a.created_at) - new Date(b.created_at);
                }
            });

            // Show all PRs (no limit)

            // Calculate stats for the filtered PRs
            const mergedCount = filteredPRs.filter(pr => pr.merged_at).length;
            const openCount = filteredPRs.filter(pr => pr.state === 'open').length;
            const closedCount = filteredPRs.filter(pr => !pr.merged_at && pr.state === 'closed').length;
            const totalCount = filteredPRs.length;

            // Calculate date range
            if (totalCount > 0) {
                const dates = filteredPRs.map(pr => new Date(pr.created_at));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const dateRange = `${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`;

                // Calculate duration statistics for merged PRs
                const mergedPRsWithDuration = filteredPRs.filter(pr => pr.merged_at && pr.timeToMerge !== null);
                let durationStats = '';

                if (mergedPRsWithDuration.length > 0) {
                    const durations = mergedPRsWithDuration.map(pr => pr.timeToMerge).sort((a, b) => a - b);
                    const count = durations.length;

                    const min = durations[0];
                    const max = durations[count - 1];
                    const avg = durations.reduce((sum, d) => sum + d, 0) / count;
                    const median = count % 2 === 0 ?
                        (durations[Math.floor(count/2) - 1] + durations[Math.floor(count/2)]) / 2 :
                        durations[Math.floor(count/2)];

                    const p15Index = Math.floor(count * 0.15);
                    const p75Index = Math.floor(count * 0.75);
                    const p95Index = Math.floor(count * 0.95);
                    const p15 = durations[p15Index];
                    const p75 = durations[p75Index];
                    const p95 = durations[p95Index];

                    // Calculate standard deviation
                    const variance = durations.reduce((sum, d) => sum + Math.pow(d - avg, 2), 0) / count;
                    const stdDev = Math.sqrt(variance);

                    // Format duration stats across multiple lines
                    durationStats = {
                        count,
                        line1: `Avg: ${avg.toFixed(1)}d`,
                        line2: `Min: ${min.toFixed(1)}d | P15: ${p15.toFixed(1)}d | Median: ${median.toFixed(1)}d | P75: ${p75.toFixed(1)}d | P95: ${p95.toFixed(1)}d | Max: ${max.toFixed(1)}d | StdDev: ${stdDev.toFixed(1)}d`
                    };
                }

                // Update stats bar with compact 5-line format
                let statsHTML = `<div style="font-size: 12px; line-height: 1.5;">`;

                // Line 1: Showing X PRs
                statsHTML += `<div><strong>Showing ${totalCount.toLocaleString()} PRs</strong></div>`;

                // Line 2: Status breakdown
                statsHTML += `<div><strong>Status:</strong> <span style="color: #28a745;">‚óè</span> Merged: ${mergedCount.toLocaleString()} (${((mergedCount/totalCount)*100).toFixed(1)}%) | <span style="color: #ffc107;">‚óè</span> Open: ${openCount.toLocaleString()} (${((openCount/totalCount)*100).toFixed(1)}%) | <span style="color: #dc3545;">‚óè</span> Closed: ${closedCount.toLocaleString()} (${((closedCount/totalCount)*100).toFixed(1)}%)</div>`;

                // Line 3: Date Range
                statsHTML += `<div><strong>Date Range:</strong> ${dateRange}</div>`;

                // Line 4-5: Duration stats (if available)
                if (durationStats) {
                    statsHTML += `<div><strong>Duration (${durationStats.count} merged PRs):</strong> ${durationStats.line1}</div>`;
                    statsHTML += `<div style="font-size: 11px;">${durationStats.line2}</div>`;
                }

                statsHTML += `</div>`;
                statsContainer.innerHTML = statsHTML;
            } else {
                statsContainer.innerHTML = `
                    <div style="color: #666; margin-bottom: 5px; font-weight: 600;">Current Filters</div>
                    <div style="color: #dc3545; font-weight: 500;">No PRs match filters</div>
                `;
            }

            if (filteredPRs.length === 0) {
                return;
            }

            const margin = {top: 20, right: 100, bottom: 60, left: 0};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = Math.max(400, filteredPRs.length * 4) - margin.top - margin.bottom;

            const svg = container
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Calculate date range
            const allDates = [];
            filteredPRs.forEach(pr => {
                allDates.push(new Date(pr.created_at));
                if (pr.closed_at) allDates.push(new Date(pr.closed_at));
                if (pr.merged_at) allDates.push(new Date(pr.merged_at));
            });

            const minDate = d3.min(allDates);
            const maxDate = d3.max(allDates);

            const x = d3.scaleTime()
                .domain([minDate, maxDate])
                .range([0, width]);

            const y = d3.scaleBand()
                .range([0, height])
                .domain(filteredPRs.map((pr, i) => i))
                .padding(0);

            const colorScale = d3.scaleOrdinal()
                .domain(['merged', 'open', 'closed'])
                .range(['#28a745', '#ffc107', '#dc3545']);

            // Add bars for each PR
            filteredPRs.forEach((pr, i) => {
                const startDate = new Date(pr.created_at);
                const endDate = pr.merged_at ? new Date(pr.merged_at) :
                              pr.closed_at ? new Date(pr.closed_at) :
                              new Date(); // Use current date for open PRs

                // Determine actual state: merged PRs have merged_at, closed PRs don't
                const actualState = pr.merged_at ? 'merged' : pr.state;

                // Main bar
                const barWidth = x(endDate) - x(startDate);
                g.append("rect")
                    .attr("x", x(startDate))
                    .attr("y", y(i))
                    .attr("width", Math.max(2, barWidth))
                    .attr("height", 1)
                    .attr("fill", colorScale(actualState))
                    .attr("opacity", actualState === 'open' ? 0.7 : 1)
                    .attr("stroke", "#333")
                    .attr("stroke-width", 0.5)
                    .on("mouseover", function(event) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        const duration = pr.timeToMerge !== null ?
                            `${pr.timeToMerge.toFixed(1)} days` :
                            pr.state === 'open' ? `${Math.round((Date.now() - startDate) / (1000 * 60 * 60 * 24))} days (ongoing)` :
                            'N/A';
                        tooltip.html(`
                            <strong>PR #${pr.number}</strong><br/>
                            ${pr.title}<br/>
                            <strong>User:</strong> ${pr.user}<br/>
                            <strong>Repo:</strong> ${pr.repository}<br/>
                            <strong>Status:</strong> ${actualState}<br/>
                            <strong>Created:</strong> ${startDate.toLocaleDateString()}<br/>
                            <strong>Duration:</strong> ${duration}
                        `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    })
                    .on("click", function(event) {
                        // Open GitHub PR page in new tab
                        const githubUrl = `https://github.com/${getRepoOwner(pr.repository)}/${pr.repository}/pull/${pr.number}`;
                        window.open(githubUrl, '_blank');
                    })
                    .style("cursor", "pointer");

                // Remove PR labels to save space
            });

            // Add X axis at bottom
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%Y-%m")));

            // Add X axis at top
            g.append("g")
                .call(d3.axisTop(x).tickFormat(d3.timeFormat("%Y-%m")));

            // Add X axis label
            g.append("text")
                .attr("transform", `translate(${width/2}, ${height + margin.bottom})`)
                .style("text-anchor", "middle")
                .text("Timeline");

            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width + margin.left + 10}, ${margin.top})`);

            const legendItems = [
                { status: 'merged', label: 'Merged', color: '#28a745' },
                { status: 'open', label: 'Open', color: '#ffc107' },
                { status: 'closed', label: 'Closed', color: '#dc3545' }
            ];

            legendItems.forEach((item, i) => {
                const legendRow = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);

                legendRow.append("rect")
                    .attr("width", 16)
                    .attr("height", 16)
                    .attr("fill", item.color);

                legendRow.append("text")
                    .attr("x", 20)
                    .attr("y", 12)
                    .style("font-size", "12px")
                    .text(item.label);
            });

            // Remove summary text to save space
        }

        // Initialize on load
        window.addEventListener('load', () => {
            loadData();
            initTOC();
        });

        // Initialize TOC scroll highlighting and folding
        function initTOC() {
            const toc = document.getElementById('toc');
            const tocHeader = toc.querySelector('h3');
            const sections = document.querySelectorAll('[id$="-section"], #dig-for-more');
            const tocLinks = document.querySelectorAll('.toc a');

            // Add folding functionality
            tocHeader.addEventListener('click', () => {
                toc.classList.toggle('collapsed');
                // Save state to localStorage
                localStorage.setItem('tocCollapsed', toc.classList.contains('collapsed'));
            });

            // Restore collapsed state from localStorage
            if (localStorage.getItem('tocCollapsed') === 'true') {
                toc.classList.add('collapsed');
            }

            function updateActiveLink() {
                const scrollPosition = window.scrollY + 100; // Offset for better highlighting

                let currentSection = '';
                sections.forEach(section => {
                    if (section.offsetTop <= scrollPosition) {
                        currentSection = '#' + section.id;
                    }
                });

                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === currentSection) {
                        link.classList.add('active');
                    }
                });
            }

            // Update on scroll
            window.addEventListener('scroll', updateActiveLink);

            // Add smooth scrolling to TOC links
            tocLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        // Expand TOC if collapsed when clicking a link
                        if (toc.classList.contains('collapsed')) {
                            toc.classList.remove('collapsed');
                            localStorage.setItem('tocCollapsed', 'false');
                        }
                        window.scrollTo({
                            top: targetElement.offsetTop - 20,
                            behavior: 'smooth'
                        });
                    }
                });
            });

            // Initial update
            updateActiveLink();
        }
    </script>

    <div class="chart-container" id="dig-for-more" style="background: #f8f9fa; border-top: 2px solid #ddd; margin-top: 50px; padding: 30px; text-align: center;">
        <h2 style="color: #333; margin-bottom: 15px;">üîç Dig for More</h2>
        <p style="color: #666; margin-bottom: 20px;">Want to explore the raw data or perform your own analysis?</p>
        <a href="data.json" download="comfyui-pr-speed-data.json"
           style="display: inline-block; padding: 12px 30px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; font-weight: 500; transition: background 0.3s;"
           onmouseover="this.style.background='#0056b3'"
           onmouseout="this.style.background='#007bff'">
            üìä Download data.json
        </a>
        <p style="color: #999; font-size: 12px; margin-top: 15px;">
            Contains all PR data, statistics, and metrics used in this dashboard
        </p>
    </div>
</body>
</html>